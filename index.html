<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Junior Chef: Confectionary Line</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7e6e6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        #app-container {
            width: 100%;
            max-width: 450px; /* Mobile vertical view */
            height: 100vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        /* Style for all game screens/views */
        .game-screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* Intro Screen Specific Styles */
        #intro-screen {
            background-color: #000000;
            justify-content: space-between; 
            padding-top: 10vh; 
        }
        .intro-main-text {
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            font-size: 3.5rem; 
            line-height: 1; 
            color: #ffffff; 
            letter-spacing: 0.05em;
            margin: 0; 
            padding: 0;
            text-align: center; 
        }
        .intro-sub-text {
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            font-size: 1.5rem;
            color: #ffffff; 
            margin: 0; 
            padding: 0;
            line-height: 1; 
            margin-top: -5px; 
            position: relative;
            left: 5px; 
        }
        .intro-container {
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            justify-content: flex-start; 
            align-items: center; 
            padding-top: 20vh; 
        }
        #splashMessage {
             margin-top: 15vh;
             visibility: hidden;
        }
        .copyright-text {
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            font-size: 1rem;
            margin-bottom: 20px;
            color: #ffffff;
        }

        /* Main Menu Styles */
        #main-menu-screen img {
             width: 150px;
             height: 150px;
             margin-bottom: 10px;
        }
        .main-title {
             font-size: 4rem;
             font-weight: 900;
             letter-spacing: -2px;
             line-height: 1;
             text-shadow: 2px 2px #ec4899; /* Pink shadow for effect */
             margin-bottom: 3rem;
        }

        /* Button Style */
        .menu-button {
            padding: 1rem 3rem;
            margin: 0.75rem 0;
            font-size: 1.5rem;
            font-weight: 700;
            border-radius: 9999px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.15s ease-in-out;
        }
        .menu-button:hover {
            transform: scale(1.05);
        }

        /* Game Screen Styles */
        #game-view {
            display: flex;
            flex-direction: column;
            background-color: #f0f0f0; 
            justify-content: flex-start;
        }
        #gameCanvas {
            background-color: #f7f7f7;
            touch-action: manipulation;
            flex-grow: 1;
        }
    </style>
</head>
<body>

<div id="app-container">

    <!-- 1. INTRO SCREEN (Asonik Studios - Splash) -->
    <div id="intro-screen" class="game-screen text-white">
        
        <div class="intro-container">
            <h1 id="splashTitle" class="intro-main-text">Asonik Studios</h1>
            <p id="splashSubtitle" class="intro-sub-text">–ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç</p>
            <p id="splashMessage" class="text-gray-400 mt-4 text-sm mb-8">–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤...</p>
        </div>
        
        <p class="copyright-text">2025¬©</p>
    </div>

    <!-- 2. MAIN MENU SCREEN -->
    <div id="main-menu-screen" class="game-screen bg-pink-100 p-8">
        <!-- –õ–û–ì–û–¢–ò–ü: –í–†–ï–ú–ï–ù–ù–ê–Ø –ó–ê–ì–õ–£–®–ö–ê. –í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –≤–∞—à—É —Å—Å—ã–ª–∫—É —Å ImgBB! -->
        <img src="https://placehold.co/150x150/FFC0CB/000000?text=CAKE+LOGO" 
             alt="Cake Logo" 
             class="rounded-full shadow-xl mb-6">
        
        <!-- –°–ª–∏—Ç–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ JuniorChef -->
        <h1 class="main-title font-black text-pink-600 text-center">JuniorChef</h1>
        
        <button id="playButton" class="menu-button bg-green-500 text-white hover:bg-green-600">
            –ò–ì–†–ê–¢–¨
        </button>
        <button id="settingsButton" class="menu-button bg-blue-500 text-white hover:bg-blue-600 opacity-50 cursor-not-allowed">
            –ù–ê–°–¢–†–û–ô–ö–ò
        </button>
        <div class="mt-8 p-4 bg-white rounded-lg shadow-md text-sm text-gray-700">
            <p>–í–∞—à ID: <span id="displayUserId" class="font-mono text-xs text-gray-500">–ó–∞–≥—Ä—É–∑–∫–∞...</span></p>
        </div>
    </div>

    <!-- 3. GAME VIEW (–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –∏–≥—Ä–æ–π) -->
    <div id="game-view" class="game-screen">
        <!-- Score & Order Header -->
        <div class="w-full bg-yellow-400 text-gray-800 p-2 shadow-md flex justify-between items-center sticky top-0 z-10">
            <div class="text-sm font-semibold">–°–ß–ï–¢: <span id="scoreDisplay" class="text-lg font-extrabold">0</span></div>
            <div class="text-sm font-semibold">–ü–†–û–ì–†–ï–°–°: <span id="orderProgress" class="text-lg font-extrabold text-red-600">0 / 0</span></div>
        </div>
        
        <!-- Order Display (Visible above canvas) -->
        <div id="currentOrderDisplay" class="w-full bg-orange-200 p-2 text-center text-sm font-bold text-gray-700">
            –¢—Ä–µ–±—É–µ–º—ã–π —Ç–æ—Ä—Ç:
        </div>

        <!-- Canvas for the conveyor belt and cake -->
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- 4. GAME OVER SCREEN (–ü—É—Å—Ç–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä) -->
    <div id="game-over-screen" class="game-screen bg-pink-100 p-8">
        <h1 class="text-5xl font-black text-red-600 mb-4 text-center">–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h1>
        <p class="text-2xl font-bold mb-6">–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á–µ—Ç: <span id="finalScoreDisplay" class="text-red-600">0</span></p>
        
        <button id="restartButton" class="menu-button bg-green-500 text-white hover:bg-green-600">
            –ò–ì–†–ê–¢–¨ –°–ù–û–í–ê
        </button>
        <button id="toMenuButton" class="menu-button bg-blue-500 text-white hover:bg-blue-600">
            –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ
        </button>

        <div class="mt-8 text-center text-gray-600">
             <p>–¢–∞–±–ª–∏—Ü–∞ —Ä–µ–∫–æ—Ä–¥–æ–≤ (—Å–∫–æ—Ä–æ)</p>
        </div>
    </div>

</div>

<!-- Game Script -->
<script type="module">
    // ===============================================
    // 1. FIREBASE SETUP (DISABLED FOR STABILITY)
    // ===============================================
    
    // –í–∫–ª—é—á–µ–Ω–∏–µ Firebase —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∫–æ—Ä–¥–æ–≤.
    // –ü–æ–∫–∞ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–∫–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å –∫–æ–¥–æ–º.
    let userId = null;
    let isAuthReady = true; 

    // ===============================================
    // 2. SCREEN MANAGEMENT
    // ===============================================

    const screens = {
        intro: document.getElementById('intro-screen'),
        menu: document.getElementById('main-menu-screen'),
        game: document.getElementById('game-view'),
        gameOver: document.getElementById('game-over-screen')
    };
    let currentScreen = 'intro';

    function showScreen(name) {
        Object.keys(screens).forEach(key => {
            screens[key].style.display = key === name ? 'flex' : 'none';
        });
        currentScreen = name;
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º/–æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–æ–≥–∏–∫—É –∏–≥—Ä—ã
        if (name === 'game') {
            if (!isGameRunning) {
               startGame();
            }
        } else if (isGameRunning) {
             isGameRunning = false;
        }
        
        if (name === 'game') {
             resizeCanvas();
        }
    }
    
    let isTransitioning = false; 
    let assetsLoaded = false; 

    function startSplashTransition() {
        if (isTransitioning || !assetsLoaded) return;
        
        isTransitioning = true;
        
        screens.intro.removeEventListener('click', startSplashTransition);
        document.removeEventListener('keydown', handleSplashKeydown);
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ –∑–∞—Å—Ç–∞–≤–∫–∞ "–∑–∞–ø—É—Å—Ç–∏–ª–∞—Å—å"
        document.getElementById('splashMessage').textContent = '–°—Ç—É–¥–∏—è Asonik –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç...';
        document.getElementById('splashMessage').style.visibility = 'hidden'; 

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ—Ö–æ–¥ –≤ –º–µ–Ω—é —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
        setTimeout(() => {
            showScreen('menu'); 
            isTransitioning = false;
        }, 3000); 
    }
    
    function handleSplashKeydown(e) {
        if (currentScreen === 'intro' && (e.code === 'Space' || e.key === 'Enter')) {
             startSplashTransition();
        }
    }

    // --- ASSET LOADING (Simplified to just check auth status) ---
    function loadAssets() {
        // –ò–º–∏—Ç–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤
        const INGREDIENT_TYPES = ['–±–∞–∑–∞', '–≤–∞–Ω–∏–ª—å', '—à–æ–∫–æ–ª–∞–¥', '–≥–ª–∞–∑—É—Ä—å', '–≤–∏—à–Ω—è'];
        const totalAssets = INGREDIENT_TYPES.length;
        const introMessage = document.getElementById('splashMessage');

        // –ò–º–∏—Ç–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏
        let loadedCount = 0;
        const interval = setInterval(() => {
            loadedCount++;
            introMessage.textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤: ${loadedCount}/${totalAssets}`;
            if (loadedCount >= totalAssets) {
                clearInterval(interval);
                assetsLoaded = true;
                // –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞
                introMessage.textContent = '–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å...'; 
                introMessage.style.visibility = 'visible';
                
                // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ –º–µ–Ω—é
                screens.intro.addEventListener('click', startSplashTransition);
                document.addEventListener('keydown', handleSplashKeydown);
            }
        }, 100);
    }

    // Menu to Game
    document.getElementById('playButton').addEventListener('click', () => {
        showScreen('game');
    });

    // Game Over to Menu
    document.getElementById('toMenuButton').addEventListener('click', () => {
        showScreen('menu');
    });

    // Game Over to Game
    document.getElementById('restartButton').addEventListener('click', () => {
        showScreen('game');
    });
    
    // Settings (Placeholder)
    document.getElementById('settingsButton').addEventListener('click', () => {
        console.log("Settings not implemented yet.");
    });


    // ===============================================
    // 3. GAME LOGIC (Conveyor Line) - –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ê
    // ===============================================

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const orderProgressDisplay = document.getElementById('orderProgress');
    const currentOrderDisplay = document.getElementById('currentOrderDisplay');
    const finalScoreDisplay = document.getElementById('finalScoreDisplay');

    // Game state variables
    let score = 0;
    let gameLoopRef = null;
    let isGameRunning = false;

    let currentCake = []; 
    let targetOrder = []; 
    let ingredientsOnBelt = []; 
    let currentOrderStep = 0; 

    // Constants
    const BLOCK_HEIGHT = 40;
    const BLOCK_WIDTH = 80;
    let BELT_SPEED = 1.5; // –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∫–æ–Ω–≤–µ–π–µ—Ä–∞
    
    // –ü–æ–∑–∏—Ü–∏–∏
    let CONVEYOR_Y = 0; 
    let DROP_ZONE_X = 0; 
    let CAKE_BASE_Y = 0;
    const CAKE_BASE_CENTER_X_OFFSET = -20; 

    // –¢–∏–ø—ã –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ (–¶–≤–µ—Ç–Ω–æ–π —Ä–µ–∂–∏–º)
    const INGREDIENTS = {
        '–±–∞–∑–∞': { 
            display: '–ö–û–†–ñ', 
            color: '#8B4513', 
            img: { isFallback: true, color: '#8B4513' }
        },
        '–≤–∞–Ω–∏–ª—å': { 
            display: '–í–ê–ù–ò–õ–¨', 
            color: '#FFF8DC', 
            img: { isFallback: true, color: '#FFF8DC' }
        },
        '—à–æ–∫–æ–ª–∞–¥': { 
            display: '–®–û–ö–û–õ–ê–î', 
            color: '#A0522D', 
            img: { isFallback: true, color: '#A0522D' }
        },
        '–≥–ª–∞–∑—É—Ä—å': { 
            display: '–ì–õ–ê–ó–£–†–¨', 
            color: '#ADD8E6', 
            img: { isFallback: true, color: '#ADD8E6' }
        },
        '–≤–∏—à–Ω—è': { 
            display: '–í–ò–®–ù–Ø', 
            color: '#DC143C', 
            img: { isFallback: true, color: '#DC143C' }
        }
    };
    const INGREDIENT_TYPES = Object.keys(INGREDIENTS);
    let lastIngredientSpawnTime = 0;
    const SPAWN_INTERVAL = 2000; 

    
    // Adjust canvas size dynamically
    function resizeCanvas() {
        // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –º—ã –Ω–∞ —ç–∫—Ä–∞–Ω–µ –∏–≥—Ä—ã –ø–µ—Ä–µ–¥ –∑–∞–ø—Ä–æ—Å–æ–º —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        if (currentScreen !== 'game') return;

        const gameView = document.getElementById('game-view');
        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—ã—Å–æ—Ç—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —á—Ç–æ–±—ã Canvas –∑–∞–Ω—è–ª –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –º–µ—Å—Ç–æ
        const headerHeight = gameView.children[0].offsetHeight + gameView.children[1].offsetHeight;
        canvas.width = gameView.clientWidth;
        canvas.height = gameView.clientHeight - headerHeight;
        
        // Set key positions based on new height
        CONVEYOR_Y = canvas.height - BLOCK_HEIGHT - 30; // Y position of the conveyor surface
        DROP_ZONE_X = canvas.width * 0.7 + CAKE_BASE_CENTER_X_OFFSET; // Drop location (70% across)
        CAKE_BASE_Y = canvas.height - 30; // Y position of the bottom of the cake stand area
        
        if (isGameRunning) {
            draw();
        }
    }
    window.addEventListener('resize', resizeCanvas);
    

    // --- GAME FLOW ---

    function startGame() {
        if (!assetsLoaded) {
            console.error("Assets not loaded yet!");
            return;
        }
        if (gameLoopRef) cancelAnimationFrame(gameLoopRef);
        score = 0;
        currentOrderStep = 0;
        ingredientsOnBelt = [];
        currentCake = [];
        isGameRunning = true;
        BELT_SPEED = 1.5;
        
        generateNewOrder();
        resizeCanvas(); 
        
        gameLoopRef = requestAnimationFrame(gameLoop);
    }
    
    function gameOver() {
        isGameRunning = false;
        if (gameLoopRef) cancelAnimationFrame(gameLoopRef);
        
        finalScoreDisplay.textContent = score;
        showScreen('gameOver');
    }

    // --- ORDER MANAGEMENT ---

    function generateNewOrder() {
        // Order: Base + 2-4 random layers
        targetOrder = ['–±–∞–∑–∞'];
        const numLayers = 2 + Math.floor(Math.random() * 3); 
        
        for (let i = 0; i < numLayers; i++) {
            let randomType;
            do {
                randomType = INGREDIENT_TYPES[1 + Math.floor(Math.random() * (INGREDIENT_TYPES.length - 1))];
            } while (targetOrder.length > 1 && randomType === targetOrder[targetOrder.length - 1]); 
            
            targetOrder.push(randomType);
        }
        
        currentOrderStep = 0;
        currentCake = [];
        updateOrderDisplay();
        
        // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏/—Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞
        BELT_SPEED = Math.min(BELT_SPEED + 0.1, 4);
    }

    function updateOrderDisplay() {
        let text = '–¢—Ä–µ–±—É–µ–º—ã–π —Ç–æ—Ä—Ç: ';
        let progressHtml = '';
        
        targetOrder.forEach((type, index) => {
            const isCurrent = index === currentOrderStep;
            const status = index < currentOrderStep ? '‚úÖ' : isCurrent ? 'üü°' : '‚ö´';
            progressHtml += `<span class="px-1">${status}</span>`;
            
            const colorClass = index < currentOrderStep ? 'text-green-600' : (isCurrent ? 'text-red-600' : 'text-gray-700');
            text += `<span class="${colorClass}">${INGREDIENTS[type].display}</span> `;
            if (index < targetOrder.length - 1) text += '-> ';
        });
        
        currentOrderDisplay.innerHTML = text; 
        orderProgressDisplay.innerHTML = progressHtml;
    }
    
    function completeOrder() {
        score += targetOrder.length * 10; // Bonus points for completing a cake
        generateNewOrder();
    }

    // --- INGREDIENT SPAWNING ---

    function spawnIngredient(timestamp) {
        // –£–º–µ–Ω—å—à–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å–ø–∞—É–Ω–∞ —Å —É–≤–µ–ª–∏—á–µ–Ω–∏–µ–º —Å—á–µ—Ç–∞ –¥–ª—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
        const dynamicInterval = Math.max(1000, SPAWN_INTERVAL - score * 50);

        if (timestamp - lastIngredientSpawnTime > dynamicInterval) {
            // Randomly select type 
            const typeIndex = Math.floor(Math.random() * (INGREDIENT_TYPES.length));
            const randomType = INGREDIENT_TYPES[typeIndex];

            ingredientsOnBelt.push({
                type: randomType,
                x: -BLOCK_WIDTH, 
                y: CONVEYOR_Y,
                width: BLOCK_WIDTH,
                color: INGREDIENTS[randomType].color, // color is needed for fallback
                isDropped: false
            });
            lastIngredientSpawnTime = timestamp;
        }
    }

    // --- GAME INPUT (Drop action) ---

    // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Å–ª—É—à–∞—Ç–µ–ª—å Canvas —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
    if (canvas) canvas.addEventListener('click', handleDrop);
    
    function handleDrop(event) {
        if (!isGameRunning || currentScreen !== 'game') return;

        // 1. Get click coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        // 2. Find the ingredient that was clicked
        let clickedIngredient = null;
        for (const ing of ingredientsOnBelt) {
            if (!ing.isDropped && 
                clickX >= ing.x && 
                clickX <= ing.x + BLOCK_WIDTH && 
                clickY >= ing.y && 
                clickY <= ing.y + BLOCK_HEIGHT) {
                clickedIngredient = ing;
                break;
            }
        }
        
        if (!clickedIngredient) return; // Ignore if no ingredient was clicked

        const requiredType = targetOrder[currentOrderStep];
        
        // 3. The core logic: check if the type matches
        if (clickedIngredient.type === requiredType) {
            // SUCCESS: Correct ingredient dropped
            
            // Mark as dropped (it will be removed in the next update loop)
            clickedIngredient.isDropped = true;

            const newBlock = {
                type: clickedIngredient.type,
                width: BLOCK_WIDTH,
            };
            
            currentCake.push(newBlock);
            
            currentOrderStep++;
            score += 5; 
            updateOrderDisplay();
            
            // Check if the order is complete
            if (currentOrderStep === targetOrder.length) {
                setTimeout(completeOrder, 500); // Small delay to visualize completion
            }
            
        } else {
            // FAILURE: Wrong ingredient dropped
            gameOver();
            console.log(`Wrong ingredient dropped! Needed: ${INGREDIENTS[requiredType].display}, Got: ${INGREDIENTS[clickedIngredient.type].display}`);
        }
    }


    // --- DRAWING FUNCTIONS ---

    function drawBlock(block, xPosition, yPosition) {
        // –ó–¥–µ—Å—å –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Ü–≤–µ—Ç–Ω–æ–π —Ä–µ–∂–∏–º
        const asset = INGREDIENTS[block.type];

        // Draw colored block
        ctx.fillStyle = asset.color;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetY = 2;

        ctx.fillRect(xPosition, yPosition, BLOCK_WIDTH, BLOCK_HEIGHT);
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(xPosition, yPosition, BLOCK_WIDTH, BLOCK_HEIGHT);
        
        // Add text for prototype
        ctx.fillStyle = '#333';
        ctx.font = '10px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(INGREDIENTS[block.type].display, xPosition + BLOCK_WIDTH / 2, yPosition + BLOCK_HEIGHT / 2 + 4);
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Draw Conveyor Belt 
        ctx.fillStyle = '#654321'; // Darker brown
        ctx.fillRect(0, CONVEYOR_Y + BLOCK_HEIGHT, canvas.width, 30);
        
        // 2. Draw Built Cake (fixed position near drop zone)
        if (currentCake.length > 0) {
            currentCake.forEach((block, index) => {
                // –°–ª–æ–∏ —Ä–∏—Å—É—é—Ç—Å—è —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
                const yPos = CAKE_BASE_Y - (currentCake.length - index) * BLOCK_HEIGHT;
                const xPos = DROP_ZONE_X - BLOCK_WIDTH / 2;
                drawBlock(block, xPos, yPos);
            });
        }
        
        // 3. Draw Ingredients on Belt
        ingredientsOnBelt.forEach(ing => {
            if (!ing.isDropped) {
               drawBlock(ing, ing.x, CONVEYOR_Y);
            }
        });

        // Update HTML score
        scoreDisplay.textContent = score;
    }

    // --- GAME UPDATE ---

    function update(timestamp) {
        // Handle ingredient spawning
        spawnIngredient(timestamp);
        
        // 1. Move ingredients on the belt
        ingredientsOnBelt.forEach(ing => {
            if (!ing.isDropped) {
                ing.x += BELT_SPEED;
            }
        });

        // 2. Remove ingredients that went off-screen (fail condition)
        ingredientsOnBelt = ingredientsOnBelt.filter(ing => {
            if (!ing.isDropped && ing.x > canvas.width) {
                // FAILURE: Ingredient missed!
                gameOver();
                return false;
            }
            // Remove ingredients that were dropped (isDropped=true) AND are off-screen (cleanup)
            return ing.x < canvas.width;
        });
    }

    // --- GAME LOOP ---

    function gameLoop(timestamp) {
        if (!isGameRunning) return;
        
        update(timestamp);
        draw();
        
        gameLoopRef = requestAnimationFrame(gameLoop);
    }
    
    // Ensure the first screen is shown on load and start asset loading
    window.onload = function () {
        loadAssets(); // Start loading assets first
        showScreen('intro');
    }

    // ===============================================
    // 4. FIREBASE HIGH SCORE FUNCTIONS (Future step)
    // ===============================================
    /*
    async function saveHighScore(finalScore) {
        if (!isAuthReady || !userId) {
            console.warn("Auth not ready or User ID missing. Cannot save score.");
            return;
        }

        try {
            await addDoc(collection(db, SCORES_COLLECTION_PATH), {
                userId: userId,
                score: finalScore,
                timestamp: Date.now()
            });
            console.log("Score saved successfully!");
        } catch (e) {
            console.error("Error saving score: ", e);
        }
    }
    */
</script>
</body>
</html>
